#define _CRT_SECURE_NO_WARNINGS

#include<stdio.h>
#include<conio.h>
#include<stdlib.h>
#include<time.h>
#include<string.h>
#include<locale.h>

struct Person
{
	char FirstName[20];
	char LastName[20];
	int Age;
};

void EnterPerson(Person & Obj);
/*void CopyPerson(Person &from, Person &to);
void PrintPerson(Person &Obj);
Person *AddToEnd(Person *M, int &k, Person &Obj);
Person *SortByAge(Person *M, int k);
Person *SortByAlphabet(Person *M, int k);
void SearchPersonByFirstname(Person *M, int k, char *FN);
void SearchPersonByLastname(Person *M, int k, char *LN);
void SearchPersonByAge(Person *M, int k, int A);
Person *DeletePerson(Person *M, int &k, Person &Obj);*/
void ShowAll(Person *M, int k);
/*Person *DeleteAll(Person *M, int &k);*/

int menu2();
int menu1();


void EnterPerson(Person & Obj)
{
//структура Obj заполняется с консоли (&Obj - link - даёт доступ сразу к Person)
 	system("cls");
	printf("\nEnter firstname: ");
	fflush(stdin);
	scanf("%s", Obj.FirstName);

	printf("\nEnter lastname: ");
	fflush(stdin);
	scanf("%s", Obj.LastName);

	printf("\nEnter age: ");
	fflush(stdin);
	scanf("%d", &Obj.Age);
}

/*
void CopyPerson(Person &from, Person &to)
{
//необходимо скопировать соответствующие поля
//из структуры from в структуру to
//строки копируются через strcpy
}
*/
void PrintPerson(Person &Obj)
{
//необходимо вывести все поля структуры Obj на консоль
	printf("\n%-20s%-20s%d", Obj.FirstName, Obj.LastName, Obj.Age);
}



Person *AddToEnd(Person *M, int &k, Person &Obj)
//M   - 1 параметр - существующий массив структур(!!!)
//k   - 2 параметр - размер массива(!!!)
//Obj - 3 - структура для добавления(!!!)
{
	system("cls");
	//необходимо добавить структуру в конец массива структур
	if (k > 0)
	{
		Person *M1 = (Person*)malloc((k + 1) * sizeof(Person)); //(k + 1) - amount of array elem
		//для этого создается новый массив размером k+1
		if (M1 == NULL)
		{
			system("cls");
			printf("No memory allocated");
			_getch();
			return M;  //return inital array M
		}

		//в него поочередно копируются все i-тые эл-ты до k
		for (int i = 0; i < k; i++)
		{
			M1[i] = M[i];  //assign value of M elements to M1 elements
		}

		free(M);
		//в k-тый элемент копируется структура, пришедшая параметром
		M1[k] = Obj;
		//размер k повышается на 1
		k++;
		//возвращается указатель на новый массив
		return M1;
	}
	else
	{
		//условие, когда k не > 0
		M = (Person*)malloc(1 * sizeof(Person));
		if (M == NULL)
		{
			system("cls");
			printf("\nNo memory allocated");
			_getch();
			return M;
		}
		M[k] = Obj;
		k++;
		return M;
	}
}
/*
Person *SortByAge(Person *M, int k)
{
//первый параметр - существующий массив структур
//второй параметр - размер массива
//необходимо отсортировать имеющийся массив структур по возрастанию
//по возрастанию, сравнивая значения полей Age
//для этого используется двойной цикл for по i и j
//если Age из i-той структуры меньше, чем Age из j-той
//создается буферная структура, в нее копируется i-тая
//в i-тую копируется j-тая
//в j-тую копируется буферная
//функция возвращает указатель на отсортированный массив
}
Person *SortByAlphabet(Person *M, int k)
{
//первый параметр - существующий массив структур
//второй параметр - размер массива
//необходимо отсортировать имеющийся массив структур по возрастанию
//по возрастанию сравнивая, значения полей FirstName
//в случае их равенства, сравнивая значения LastName
//сравнения строк производится с помощью strcmp
//для этого используется двойной цикл for по i и j
//если FirstName из i-той структуры меньше, чем FirstName из j-той
//или если FirstName из i-той структуры равен FirstName из j-той
//и LastName из i-той структуры меньше, чем LastName из j-той
//создается буферная структура, в нее копируется i-тая
//в i-тую копируется j-тая
//в j-тую копируется буферная
//функция возвращает указатель на отсортированный массив
}
void SearchPersonByFirstname(Person *M, int k, char *FN)
{
//первый параметр - существующий массив структур
//второй параметр - размер массива
//третий параметр - строка с именем для поиска
//необходимо вывести на консоль все элементы из массива
//в которых FirstName совпадает с именем для поиска
//для этого прокручивается массив циклом for
//если поле FirstName i-той структуры равно имени для поиска
//то вызывается ф-ция вывода структуры
//сравнения строковых переменных через strcmp
}
void SearchPersonByLastname(Person *M, int k, char *LN)
{
//первый параметр - существующий массив структур
//второй параметр - размер массива
//третий параметр - строка с фамилией для поиска
//необходимо вывести на консоль все элементы из массива
//в которых LastName совпадает с именем для поиска
//для этого прокручивается массив циклом for
//если поле LastName i-той структуры равно фамилии для поиска
//то вызывается ф-ция вывода структуры
//сравнения строковых переменных через strcmp
}
void SearchPersonByAge(Person *M, int k, int A)
{
//первый параметр - существующий массив структур
//второй параметр - размер массива
//третий параметр - возраст для поиска
//необходимо вывести на консоль все элементы из массива
//в которых Age совпадает с возрастом для поиска
//для этого прокручивается массив циклом for
//если поле Age i-той структуры равно возрасту для поиска
//то вызывается ф-ция вывода структуры
}
Person *DeletePerson(Person *M, int &k, Person &Obj)
{
//первый параметр - существующий массив структур
//второй параметр - размер массива
//третий - структура для сравнения и удаления
//необходимо удалить из текущего массива
//все структуры совпадающие с пришедшей третьим пар-ром
//для этого создается новый массив структур
//задается переменная, отвечающая за его размер
//изначально новый массив нулевой, размер нулевой
//текущий массив прокручивается циклом for
//если поле FirstName из i-той структура из текущего массива
//не равно полю FirstName из структуры, пришедшей пар-ром
//и поле LastName из i-той структура из текущего массива
//не равно полю LastName из структуры, пришедшей пар-ром
//и поле Age из i-той структура из текущего массива
//не равно полю Age из структуры, пришедшей пар-ром
//то добавляет i-тую структуру из текущего массива
//в конец нового массива с помощью ранее написанной
//ф-ции добавления в конец
//сравнения строковых переменных через strcmp
//если условие не выполняется, то зачищает значение полей
//FirstName и LastName из i-той структуры текущего массива
//в конце переменной, отвечающей за размер текущего массива,
//которая пришла вторым параметром присваиваем значение
//переменной, отвечающей за размер нового массива
//ф-ция отдает указатель на новый массив
}*/
void ShowAll(Person *M, int k)
{
//M - первый параметр - существующий массив структур
//k - второй параметр - размер массива
//необходимо последовательно вывести все элемены массива на консоль
//текущий массив прокручивается циклом for
	system("cls");
	if (k > 0)
	{
		printf("\n=======================================================\n");
		printf("%-20s%-20s%s", "FirstName", "LastName", "Age");
		printf("\n=======================================================\n");

		for (int i = 0; i < k; i++)
		{
			PrintPerson(M[i]);
		}
	}
	else
	{
		printf("\nThere is no information in array.\n");
	}

//с помощью ранее написанной ф-ции вывода структуры в консоль
//осуществляется вывод каждой i-той структуры массива
}
/*
Person *DeleteAll(Person *M, int &k)
{
//первый параметр - существующий массив структур
//второй параметр - размер массива
//необходимо последовательно очистить все элемены массива
//текущий массив прокручивается циклом for
//неоходимо зачистить значение полей
//FirstName и LastName из i-той структуры текущего массива
//в конце переменной, отвечающей за размер текущего массива,
//которая пришла вторым параметром присваиваем нулевое значение
//ф-ция отдает указатель на пустой массив, т е ноль
}
*/
int menu2()
{
	int z;
	char str[50];

	do
	{
		system("cls");
		puts("\nEnter: ");
		puts("1 - Write in TXT\n");
		puts("2 - Write in BIN\n");
		puts("3 - Read from TXT\n");
		puts("4 - Read from BIN\n");
		puts("5 - Edit BIN\n");
		puts("0 - Exit\n");

		if (str[0] == '0')
		{
			return 0;
		}

		z = atoi(str);
		if (z == 0)
		{
			system("cls");
			printf("\nERROR!!!");
			_getch();
		}
	} 
	while (z == 0);
	return z;
}
int menu1()
{
	int z;
	char str[50];
	do
	{
		system("cls");
		puts("\nEnter: ");
		puts("1 - Sort by age\n");
		puts("2 - Sort by alphabet\n");
		puts("0 - Exit\n");

		printf(">>> ");
		fflush(stdin);
		scanf("%s", str);

		if (str[0] == '0')
		{
			return 0;
		}

		z = atoi(str);
		if (z == 0)
		{
			system("cls");
			printf("\nERROR!!!");
			_getch();
		}
	} 
	while (z == 0);
	return z;
}
int menu()
{
	int z; //var for func atoi - compiles simbols to numbers(!)
	char str[50];
	do
	{
		system("cls");
		puts("\nVvedite: ");
		puts("1 - Add new line about person");
		puts("2 - Sorting");
		puts("3 - Work with files");
		puts("4 - Search person by firstname");
		puts("5 - Search person by lastname");
		puts("6 - Search person by age");
		puts("7 - Delete line about person");
		puts("8 - Show all");
		puts("9 - Delete all");
		puts("0 - Exit");
		
		printf(">>>");
		fflush(stdin);
		scanf("%s", str);

		if (str[0] == '0') //if first element in string '0'
		{
			return 0; //return true(?)
		}

		z = atoi(str);
		if (z == 0)
		{
			system("cls");
			printf("\n\nERROR!!!");
			_getch();
		}
	} 
	while (z == 0);
	return z;
}

int main()
{
	int n = 0;				//amount of elements
	Person * Mans = 0;		//Mans - pointer to Person
	while (int z = menu())
	{
		switch (z)
		{
			case 1:
			Person P;
			EnterPerson(P);
			Mans = AddToEnd(Mans, n, P);
			break;
			/*
			case 2:
			Mans = SortByAge(Mans, n);
			break;
			case 3:
			Mans = SortByAlphabet(Mans, n);
			break;
			case 4:
			char buf[80];
			printf("Vvedite imya dlya poiska: ");
			fflush(stdin);
			gets(buf);
			printf("\n");
			SearchPersonByFirstname(Mans, n, buf);
			break;
			case 5:
			char buf[80];
			printf("Vvedite familiyu dlya poiska: ");
			fflush(stdin);
			gets(buf);
			printf("\n");
			SearchPersonByLastname(Mans, n, buf);
			break;
			case 6:
			int z;
			printf("Vvedite vozrast dlya poiska: ");
			fflush(stdin);
			scanf("%d", &z);
			printf("\n");
			SearchPersonByAge(Mans, n, z);
			break;
			case 7:
			Person P;
			EnterPerson(P);
			Mans = DeletePerson(Mans, n, P);
			break;*/
			case 8:
			ShowAll(Mans, n);
			break;
			/*case 9:
			Mans = DeleteAll(Mans, n);
			break;
			*/
		default:
			puts("nevernyi vvod!");
			break;
		}
		printf("\n\nPress any key...\n\n");
		_getch();
		system("cls");
	}

	printf("\n\nThe end!!!\n");
	_getch();
	return 0;
}

